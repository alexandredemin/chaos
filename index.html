<html lang="en">
<head>
    <meta charSet="UTF-8"/>
    <meta name="format-detection" content="telephone=no">
    <meta name="msapplication-tap-highlight" content="no">
    <meta name="viewport"
          content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width">
    <title>Chaos</title>
    <script type="text/javascript" src="Html/phaser.min.js"></script>
    <script type="text/javascript" src="Html/configs.js"></script>
    <script type="text/javascript" src="Html/autotilerules.js"></script>
    <script type="text/javascript" src="Html/ui.js"></script>
    <script type="text/javascript" src="Html/magicbook.js"></script>
    <script type="text/javascript" src="Html/player.js"></script>
    <script type="text/javascript" src="Html/baseunit.js"></script>
    <script type="text/javascript" src="Html/entity.js"></script>
    <script type="text/javascript" src="Html/unit.js"></script>
    <script type="text/javascript" src="Html/spell.js"></script>
    <script type="text/javascript" src="Html/unitstate.js"></script>
    <script type="text/javascript" src="Html/features.js"></script>
    <script type="text/javascript" src="Html/abilities.js"></script>
    <script type="text/javascript" src="Html/animation.js"></script>
    <script type="text/javascript" src="Html/shader.js"></script>
    <script type="text/javascript" src="Html/bootscene.js"></script>
    <script type="text/javascript" src="Html/gamescene.js"></script>
    <script type="text/javascript" src="Html/uiscene.js"></script>
    <script type="text/javascript" src="Html/startscene.js"></script>
    <script type="text/javascript" src="Html/aicontrol.js"></script>
    <script type="text/javascript" src="Html/aitreesearch.js"></script>
    <script type="text/javascript" src="Html/mapgenerator.js"></script>
    <style> body {
        margin: 0;
    } </style>
</head>

<body>
<script>
    // ---------- Global Error + Debug Console Overlay ----------
    (function() {

        // ---------- ERROR BOX ----------
        const box = document.createElement("div");
        box.style.position = "fixed";
        box.style.bottom = "0";
        box.style.left = "0";
        box.style.right = "0";
        box.style.maxHeight = "50%";
        box.style.overflowY = "auto";
        box.style.background = "rgba(0, 0, 0, 0.7)";
        box.style.color = "#ff8080";
        box.style.fontSize = "13px";
        box.style.padding = "10px";
        box.style.zIndex = "999999";
        box.style.whiteSpace = "pre-wrap";
        box.style.fontFamily = "monospace";
        box.style.display = "none";

        document.body.appendChild(box);

        function logToBox(msg) {
            box.style.display = "block";
            box.textContent += msg + "\n";
        }

        // ---------- ERROR HOOKS ----------
        window.onerror = function(msg, url, line, col, error) {
            logToBox(
                "ERROR: " + msg +
                "\nURL: " + url +
                "\nLine: " + line + ", Col: " + col +
                "\nStack:\n" + (error && error.stack ? error.stack : "no stack")
            );
        };

        window.addEventListener("unhandledrejection", function(event) {
            logToBox(
                "PROMISE ERROR:\n" +
                (event.reason && event.reason.stack ? event.reason.stack : JSON.stringify(event.reason))
            );
        });

        // ---------- DEBUG PANEL WITH JS INPUT + SAVE EDITOR ----------
        const panel = document.createElement("div");
        panel.style.position = "fixed";
        panel.style.bottom = "50%";
        panel.style.left = "0";
        panel.style.right = "0";
        panel.style.background = "rgba(0,0,0,0.95)";
        panel.style.color = "#fff";
        panel.style.padding = "10px";
        panel.style.fontFamily = "monospace";
        panel.style.display = "none";
        panel.style.zIndex = "1000000";

        panel.innerHTML = `
            <div style="margin-bottom:5px; font-weight:bold;">Debug Console</div>

            <textarea id="debugCmd" style="width:100%; height:60px; background:#111; color:#0f0; font-family:monospace;"></textarea>
            <button id="debugRun">Run JS</button>
            <button id="openSaveEditor">Edit Save</button>
            <button id="toggleConsoleLogs">Console Log: OFF</button>
            <button id="debugClear">Clear Log</button>
        `;

        document.body.appendChild(panel);

        // ---------- JS COMMAND EXECUTION ----------
        document.getElementById("debugRun").onclick = function() {
            const code = document.getElementById("debugCmd").value;
            try {
                let result = eval(code);
                let out;
                if (result === undefined) {
                    out = "undefined";
                } else if (typeof result === "object") {
                    try {
                        out = JSON.stringify(result, null, 2);
                    } catch (e) {
                        out = "[object]";
                    }
                } else {
                    out = String(result);
                }
                logToBox("> " + code + "\n" + out + "\n");
            } catch (e) {
                logToBox("EVAL ERROR: " + e);
            }
        };

        document.getElementById("debugClear").onclick = function() {
            box.textContent = "";
        };

        // ---------- SAVE EDITOR POPUP ----------
        document.getElementById("openSaveEditor").onclick = function() {
            const popup = document.createElement("div");
            popup.style.position = "fixed";
            popup.style.top = "0";
            popup.style.left = "0";
            popup.style.width = "100%";
            popup.style.height = "100%";
            popup.style.background = "rgba(0,0,0,0.85)";
            popup.style.zIndex = "2000000";
            popup.style.color = "#fff";
            popup.style.padding = "10px";
            popup.style.fontFamily = "monospace";

            const current = localStorage.getItem("savedGame") || "";

            popup.innerHTML = `
                <div style="margin-bottom:5px; font-weight:bold;">Save Editor</div>
                <textarea id="saveEditBox" style="width:100%; height:80%; background:#111; color:#0f0;">${current}</textarea><br>
                <button id="applySave">Apply</button>
                <button id="resetSave">Reset</button>
                <button id="closeSaveEditor">Close</button>
            `;

            document.body.appendChild(popup);

            document.getElementById("applySave").onclick = function() {
                const text = document.getElementById("saveEditBox").value;
                try {
                    JSON.parse(text); // Проверка корректности JSON
                    localStorage.setItem("savedGame", text);
                    location.reload();
                } catch (e) {
                    alert("JSON Error: " + e);
                }
            };

            document.getElementById("resetSave").onclick = function() {
                localStorage.removeItem("savedGame");
                location.reload();
            };

            document.getElementById("closeSaveEditor").onclick = function() {
                document.body.removeChild(popup);
            };
        };

        // ---------- CONSOLE.LOG HOOK ----------
        let forwardConsoleLogs = false;

        // Save originals
        const origLog = console.log;
        const origWarn = console.warn;
        const origErr = console.error;
        const origInfo = console.info;

        function hook(type, original) {
            return function(...args) {
                if (forwardConsoleLogs) {
                    try {
                        const msg = args.map(a => {
                            if (typeof a === "object") {
                                try { return JSON.stringify(a); }
                                catch { return "[object]"; }
                            }
                            return String(a);
                        }).join(" ");

                        logToBox(`console.${type}: ${msg}`);
                    } catch (e) {}
                }
                original.apply(console, args);
            };
        }

        console.log = hook("log", origLog);
        console.warn = hook("warn", origWarn);
        console.error = hook("error", origErr);
        console.info = hook("info", origInfo);

        // Button toggle
        document.getElementById("toggleConsoleLogs").onclick = function() {
            forwardConsoleLogs = !forwardConsoleLogs;
            this.textContent = "Console Log: " + (forwardConsoleLogs ? "ON" : "OFF");
            logToBox("Console log forwarding: " + (forwardConsoleLogs ? "ENABLED" : "DISABLED"));
        };

        // ---------- TOGGLE CONSOLE BY 5 TAPS IN TOP-LEFT ----------
        let tapCount = 0;

        function toggleConsole(ev) {
            const x = ev.touches ? ev.touches[0].clientX : ev.clientX;
            const y = ev.touches ? ev.touches[0].clientY : ev.clientY;

            if (x < 80 && y < 80) {
                tapCount++;
                if (tapCount >= 5) {
                    const visible = (box.style.display !== "none");
                    box.style.display = visible ? "none" : "block";
                    panel.style.display = visible ? "none" : "block";
                    tapCount = 0;
                }
            } else {
                tapCount = 0;
            }
        }

        document.addEventListener("touchstart", toggleConsole);
        document.addEventListener("mousedown", toggleConsole);

    })();

    //---------------------------- Global functions ----------------------------
    function clone(obj, visited = new WeakMap()) {
        if (obj === null || typeof obj !== 'object') {
            return obj;
        }
        // already visited (cloned) object
        if (visited.has(obj)) {
            return visited.get(obj);
        }
        // Date
        if (obj instanceof Date) {
            return new Date(obj.getTime());
        }
        // Map
        if (obj instanceof Map) {
            const m = new Map();
            visited.set(obj, m);
            for (const [k, v] of obj.entries()) {
                m.set(k, clone(v, visited));
            }
            return m;
        }
        // Set
        if (obj instanceof Set) {
            const s = new Set();
            visited.set(obj, s);
            for (const v of obj.values()) {
                s.add(clone(v, visited));
            }
            return s;
        }
        // Array
        if (Array.isArray(obj)) {
            const arr = [];
            visited.set(obj, arr);
            for (const item of obj) {
                arr.push(clone(item, visited));
            }
            return arr;
        }
        // Object
        const objClone = {};
        visited.set(obj, objClone);
        for (const key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                objClone[key] = clone(obj[key], visited);
            }
        }
        return objClone;
    }
    
    const userInteractionScenario = {
        movement: 'movement',
        targetSelection: 'targetSelection',
        placeSelection: 'placeSelection'
    };

    function setInteractionScenario(scenario) {
        if(gameSettings.showEnemyMoves == true || players[playerInd].control === PlayerControl.human)
        {
            if (scenario === userInteractionScenario.movement) {
                if (selectedUnit != null) {
                    cam.startFollow(selectedUnit);
                    showArrows(selectedUnit);
                    cam.stopFollow(selectedUnit);
                }
            } else if ((scenario === userInteractionScenario.targetSelection) || (scenario === userInteractionScenario.placeSelection)) {
                hideArrows();
                if (selectedUnit != null) {
                    cam.startFollow(selectedUnit);
                    cam.stopFollow(selectedUnit);
                }
            }
        }
        activeInteractionScenario = scenario;
    }

    function randomInt(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function randomFloat(min, max) {
        return (Math.random() * (max - min + 1)) + min;
    }

    function createArrows(unit) {
        let arrU = new Arrow(ArrowType.U, unit.scene, unit.x, unit.y, 'arrow');
        let arrRU = new Arrow(ArrowType.RU, unit.scene, unit.x, unit.y, 'arrow');
        let arrR = new Arrow(ArrowType.R, unit.scene, unit.x, unit.y, 'arrow');
        let arrRD = new Arrow(ArrowType.RD, unit.scene, unit.x, unit.y, 'arrow');
        let arrD = new Arrow(ArrowType.D, unit.scene, unit.x, unit.y, 'arrow');
        let arrLD = new Arrow(ArrowType.LD, unit.scene, unit.x, unit.y, 'arrow');
        let arrL = new Arrow(ArrowType.L, unit.scene, unit.x, unit.y, 'arrow');
        let arrLU = new Arrow(ArrowType.LU, unit.scene, unit.x, unit.y, 'arrow');
        arrows.push(arrLU, arrU, arrRU, arrL, arrR, arrLD, arrD, arrRD);
    }

    function hideArrows() {
        arrows.forEach(item => item.visible = false);
    }

    function showArrows(unit) {
        if (unit != null) {
            if (unit.player.control === PlayerControl.computer) return;
            if (arrows.length === 0) createArrows(unit);
            arrows.forEach(item => {
                    if (unit.canAtackTo(item.mapOffsetX, item.mapOffsetY) === true) {
                        item.setState(ArrowState.red);
                    } else {
                        if (unit.canStepTo(item.mapOffsetX, item.mapOffsetY) === true) {
                            item.setState(ArrowState.green);
                        } else {
                            item.setState(ArrowState.disable);
                        }
                    }
                    item.setPositionToUnit(unit);
                }
            );
        }
        pointerBlocked = false;
    }

    function getUnitAtMap(mapX, mapY, player = null) {
        let untArr = units;
        if (player) untArr = player.units;
        for (let i = 0; i < untArr.length; i++) {
            if ((untArr[i].mapX === mapX) && (untArr[i].mapY === mapY)) {
                return untArr[i];
            }
        }
        return null;
    }

    function selectUnit(unit) {
        console.log('select unit ' + unit.config.name);
        if(gameSettings.showEnemyMoves == true || players[playerInd].control === PlayerControl.human)
        {
            if (selectedUnit != null) {
                selectedUnit.resetPipeline();
            }
            selectedUnit = unit;
            selectedUnit.setPipeline('Custom');//,{ gray: 1 });
            cam.startFollow(unit);
            showArrows(unit);
            //+debug
            if(players[playerInd].control === PlayerControl.human)
                if(players[playerInd].icons != null)
                {
                    players[playerInd].icons.forEach( x => { x.destroy(); });
                    players[playerInd].icons = null;
                }
            //-
            cam.stopFollow();
        }
        else selectedUnit = unit;
    }

    function selectAdjacentPlaces(centerMapX, centerMapY) {
        let res = [];
        for (let y = centerMapY - 1; y <= centerMapY + 1; y++)
            for (let x = centerMapX - 1; x <= centerMapX + 1; x++) {
                if ((x < 0) || (x >= map.width) || (y < 0) || (y >= map.height) || ((x === centerMapX) && (y === centerMapY))) continue;
                res.push([x, y]);
            }
        return res;
    }

    function selectFreeAdjacentPlaces(centerMapX, centerMapY) {
        let res = [];
        selectAdjacentPlaces(centerMapX, centerMapY).forEach(x => {
            let wallTile = wallsLayer.getTileAt(x[0], x[1]);
            if (wallTile == null) {
                let unitAtPos = getUnitAtMap(x[0], x[1]);
                if (unitAtPos == null) res.push(x);
            }
        });
        return res;
    }
  
    function selectEntities(centerMapX, centerMapY, radius) {
        let res = [];
        entities.forEach(ent => {
            let dX = Math.abs(ent.mapX - centerMapX);
            let dY = Math.abs(ent.mapY - centerMapY);
            if (dX * dX + dY * dY <= radius * radius) {
                res.push(ent);
            }
        });
        return res;
    }

    function selectUnits(centerMapX, centerMapY, playerArr, unitArr, radius) {
        let arr = [];
        let res = [];
        if (playerArr == null) {
            arr = units;
        } else {
            playerArr.forEach(pl => arr = arr.concat(pl.units));
        }
        arr.forEach(unit => {
            let fl = true;
            if (unitArr != null) {
                if (unitArr.includes(unit)) fl = false;
            }
            if (fl) {
                if (radius > 0) {
                    let dX = Math.abs(unit.mapX - centerMapX);
                    let dY = Math.abs(unit.mapY - centerMapY);
                    if (dX * dX + dY * dY <= radius * radius) {
                        res.push(unit);
                    }
                } else {
                    if ((Math.abs(unit.mapX - centerMapX) <= 1) && (Math.abs(unit.mapY - centerMapY) <= 1)) {
                        res.push(unit);
                    }
                }
            }
        });
        return res;
    }

    function deselectUnits() {
        units.forEach(unit => {
            if (unit.filtered === true) {
                unit.filtered = false;
                if(unit.visible) unit.resetPipeline();
            }
        });
    }

    function checkLineOfSight(x1, y1, x2, y2, onWall, onEntity, onUnit) {
        if (x1 === x2 && y1 === y2) return true;
        let xx1 = x1;
        let xx2 = x2;
        let yy1 = y1;
        let yy2 = y2;
        let invFlag = false;
        if (Math.abs(y2 - y1) > Math.abs(x2 - x1)) {
            invFlag = true;
            xx1 = y1;
            xx2 = y2;
            yy1 = x1;
            yy2 = x2;
        }
        let k = (yy2 - yy1) / (xx2 - xx1);
        let b = yy1 - k * xx1;
        let dx = 1;
        if (xx2 < xx1) dx = -1;
        for (let x = xx1 + dx; x !== xx2; x = x + dx) {
            let y = Math.round(k * x + b);
            let resX = x;
            let resY = y;
            if (invFlag) {
                resX = y;
                resY = x;
            }
            // check units
            let unit = getUnitAtMap(resX, resY);
            if (unit != null) {
                if (onUnit) {
                    if (onUnit(unit) === false) return false;
                } else return false;
            }
            // check entities
            const entities = Entity.getEntitiesAtMap(resX, resY);
            if(entities && entities.length > 0){
                if(onEntity){
                    for(const ent of entities) if(onEntity(ent) === false) return false;
                }
                else if(entities.some(ent => ent.config.features.blocksLOS !== false)) return false;
            }
            // check walls
            let wallTile = wallsLayer.getTileAt(resX, resY);
            if (wallTile != null) {
                //if(wallTile.properties['collides'] == true)
                if (onWall) {
                    if (onWall(wallTile) === false) return false;
                } else return false;
            }
        }
        return true;
    }

    function selectOnLineOfSight(centerX, centerY, units, onWall, onEntity, onUnit) {
        let res = [];
        units.forEach(unit => {
            if (checkLineOfSight(centerX, centerY, unit.mapX, unit.mapY, onWall, onEntity, onUnit) === true) res.push(unit);
        });
        return res;
    }

    function selectPlacesOnLineOfSight(centerX, centerY, radius, withUnits = false, withEntities = false) {
        let res = [];
        for (let r = 1; r <= radius; r++) {
            for (let y = centerY - r; y <= centerY + r; y++) {
                for (let x = centerX - r; x <= centerX + r; x++) {
                    if ((x < 0) || (x >= map.width) || (y < 0) || (y >= map.height) || ((x === centerX) && (y === centerY))) continue;
                    if ((withUnits === false) && (getUnitAtMap(x, y) != null)) continue;
                    if ((withEntities === false) && (Entity.getEntityAtMap(x, y) != null)) continue;
                    let wallTile = wallsLayer.getTileAt(x, y);
                    if (wallTile != null) continue;
                    let dX = Math.abs(x - centerX);
                    let dY = Math.abs(y - centerY);
                    if (dX * dX + dY * dY > r * r) continue;
                    if (checkLineOfSight(centerX, centerY, x, y) === true) res.push([x, y]);
                }
            }
        }
        return res;
    }

    function checkUnitVisibility(unit) {
        let enemies = [];
        players.forEach(pl => {
            if (pl !== unit.player) enemies.push(pl);
        });
        //let targets = selectUnits(unit.mapX, unit.mapY, enemies, null, 20); //unit.config.abilities.fire.config.range);
        let targets = [];
        selectUnits(unit.mapX, unit.mapY, enemies, null, 20).forEach(unt => {
            if (!unt.visible) targets.push(unt);
        });
        targets = selectOnLineOfSight(unit.mapX, unit.mapY, targets, null, null, () => {
            return true
        });
        targets.forEach(unt => {
            unt.visible = true;
        });
        //entites
        targets = [];
        selectEntities(unit.mapX, unit.mapY, 20).forEach(ent => {
            if (!ent.visible && ent.active) targets.push(ent);
        });
        targets = selectOnLineOfSight(unit.mapX, unit.mapY, targets, null, null, () => {
            return true
        });
        targets.forEach(ent => {
            ent.visible = true;
        }); 
    }

    function startTurn() {
        saveGame();
        if (players[playerInd].units.length === 0) {
            setTimeout(endTurn, 1);
            return;
        }
        let isWinner = true;
        for (let i = 0; i < players.length; i++) {
            if (i !== playerInd && players[i].units.length > 0) {
                isWinner = false;
                break;
            }
        }
        if (isWinner) {
            pointerBlocked = true;
            let scrollMsg = new ScrollMsg(uiScene, players[playerInd].name + ' won!', null);
            scrollMsg.show();
            return;
        }
        //+
        /*
        let wiz = players[playerInd].wizard;
        let places = wiz.player.aiControl.getWebPlanMap(wiz);
        wiz.player.icons = [];
        places.forEach( x => {
            let pos = map.tileToWorldXY(x.cell[0], x.cell[1]);
            let circle = wiz.scene.add.circle(pos.x + 8, pos.y + 8, 2, Math.sqrt(x.dist)*10);
            wiz.player.icons.push(circle);
            circle.setDepth(10000);
        });
        */
        //-
        if(!gameSettings.showEnemyMoves) units.forEach(unt => unt.visible = false);
        if(!gameSettings.showEnemyMoves) entities.forEach(ent => ent.visible = false);
        pointerBlocked = true;
        hideArrows();
        if (players[playerInd].control === PlayerControl.human) {
            let scrollMsg = new ScrollMsg(uiScene, players[playerInd].name + ' turn', function () {
                players[playerInd].startTurn();
            });
            scrollMsg.show();
        } else {
            players[playerInd].startTurn();
        }
        
        //+ mushrooms
        /*  
        for(let i=0; i<10; i++)
        {
            let x=randomInt(0, map.width-1);
            let y=randomInt(0, map.height-1);          
            let wallTile = wallsLayer.getTileAt(x,y);
            let entity = Entity.getEntityAtMap(x,y);
            let unt = getUnitAtMap(x,y);
            if (wallTile == null && entity == null && unt == null) {
                let mushroom = new MushroomEntity(players[playerInd].wizard.scene,0,0);
                mushroom.setPositionFromMap(x, y);
                mushroom.start();
                entities.push(mushroom);
                break;
            }
        }
        */
        //-        
    }

    function moveEntites() {
        let allMoved = true;
        for (let i = 0; i < entities.length; i++) {
            if (entities[i].moved === false) {
                allMoved = false;
                entities[i].makeMove();
                return;
            }
        }
        if (allMoved) {
            entities.forEach(ent => ent.moved = false);
            playerInd = 0;
            console.log('next player ' + playerInd);
            console.log('units: ' + players[playerInd].units.length);
            startTurn();
        }
    }

    function endTurn() {
        //+
        if(players[playerInd].icons){
            players[playerInd].icons.forEach( icon => icon.destroy() );
            players[playerInd].icons = [];
        }
        //-
        if (gameSettings.showEnemyMoves == true || players[playerInd].control === PlayerControl.human) {
            setInteractionScenario(userInteractionScenario.movement);
            if(selectedUnit != null)selectedUnit.resetPipeline();
        }
        console.log('end turn');
        console.log('prev player ' + playerInd);
        playerInd++;
        if (playerInd >= players.length) {
            moveEntites();
        } else {
            console.log('next player ' + playerInd);
            console.log('units: ' + players[playerInd].units.length);
            startTurn();
        }
    }

    function resetInteractionScenario() {
        if (selectedUnit != null) selectedUnit.stopAbility();
        setInteractionScenario(userInteractionScenario.movement);
    }

    function onEndTurn() {
        resetInteractionScenario();
        pointerBlocked = true;
        let scrollMsg = new ScrollMsg(uiScene, 'Are you sure?', function (res) {
            if (res) {
                setTimeout(endTurn, 1);
            } else {
                pointerBlocked = false;
            }
        }, ScrollType.yesno);
        scrollMsg.show();
    }

    function saveGame() {
        let savedMap = null;

        if (gameSettings.selectedMap === "random") {
            savedMap = {
                width: map.width,
                height: map.height,
                ground: groundLayer.layer.data.map(row => row.map(t => t.index)),
                walls: wallsLayer.layer.data.map(row => row.map(t => t ? t.index : null)),
                objects: objectLayer.objects
            };
        }

        const data = {
            selectedMap: gameSettings.selectedMap,
            spellDistrib: gameSettings.spellDistrib,
            magicPoints: gameSettings.magicPoints,
            showEnemyMoves: gameSettings.showEnemyMoves,
            rules: gameSettings.rules,
            playerInd,
            players: players.map(p => ({
                name: p.name,
                control: p.control,
            })),
            units: units.map(u => u.serialize()),
            entities: entities.map(e => e.serialize()),
            savedMap
        };

        localStorage.setItem("savedGame", JSON.stringify(data));
    }

    function resize() // (gameSize, baseSize, displaySize, resolution)
    {
        let displayTileWidth = window.innerWidth / 20;
        let displayTileHeight = window.innerHeight / 20;
        let displayTileSize = displayTileWidth;
        if (displayTileWidth < displayTileHeight) displayTileSize = displayTileHeight;
        if (displayTileSize > 64) displayTileSize = 64;
        let zoomFactor = displayTileSize / 16;

        let prevGroundPosX = groundLayer.x;
        let prevGroundPosY = groundLayer.y;

        game.scale.resize(window.innerWidth, window.innerHeight);

        let gameW = map.widthInPixels;
        if (gameW * zoomFactor < window.innerWidth) gameW = window.innerWidth / zoomFactor;
        let gameH = map.heightInPixels;
        if (gameH * zoomFactor < window.innerHeight) gameH = window.innerHeight / zoomFactor;
        game.config.width = gameW;
        game.config.height = gameH;

        groundLayer.setPosition((game.config.width - map.widthInPixels) / 2, (game.config.height - map.heightInPixels) / 2);
        wallsLayer.setPosition((game.config.width - map.widthInPixels) / 2, (game.config.height - map.heightInPixels) / 2);

        let offsetX = groundLayer.x - prevGroundPosX;
        let offsetY = groundLayer.y - prevGroundPosY;

        entities.forEach(item => item.setPosition(item.x + offsetX, item.y + offsetY));
        units.forEach(item => item.setPosition(item.x + offsetX, item.y + offsetY));
        arrows.forEach(item => item.setPosition(item.x + offsetX, item.y + offsetY));

        PlaceSelector.icons.forEach(item => item.setPosition(item.x + offsetX, item.y + offsetY));
        if (rangeRenderer != null) {
            rangeRenderer.setPosition(groundLayer.x, groundLayer.y);
            if (rangeRenderer.visible === true) rangeRenderer.redraw();
        }

        //const cam = game.scene.scenes[0].cameras.main;

        console.log('game.scene.scenes[0] ' + game.scene.scenes[0]);

        cam.setViewport(0, 0, window.innerWidth, window.innerHeight);
        cam.setZoom(zoomFactor);
        cam.setBounds(0, 0, game.config.width, game.config.height);
        cam.centerToBounds();
        //cam.roundPixels = true;

        let leftBorder = 0;
        if (map.widthInPixels * zoomFactor < window.innerWidth) leftBorder = groundLayer.x * zoomFactor;
        if (buttonEndTurn != null) buttonEndTurn.setPosition(leftBorder + buttonEndTurn.width / 2 + 10, window.innerHeight - buttonEndTurn.height / 2 - 10);
        //+debug
        if (buttonAIStep != null) buttonAIStep.setPosition(leftBorder + buttonAIStep.width / 2 + 120, window.innerHeight - buttonAIStep.height / 2 - 10);
        //-

        if ((book != null) && (book.visible === true)) book.resize();
        uiElements.forEach(elm => {
            if (elm.visible === true) elm.resize();
        });
    }

    var collideCallback = function (gameObject1, gameObject2) {
        let activeUnit = null;
        let passiveUnit = null;
        if (gameObject2.isMoving === true) {
            activeUnit = gameObject2;
            passiveUnit = gameObject1;
        } else if (gameObject1.isMoving === true) {
            activeUnit = gameObject1;
            passiveUnit = gameObject2;
        }
        if (activeUnit != null) {
            if (passiveUnit.constructor.name !== 'Unit') {
                var targetXY = map.tileToWorldXY(activeUnit.mapX, activeUnit.mapY);
                activeUnit.body.reset(targetXY.x + 8, targetXY.y + 8);
                activeUnit.isMoving = false;
                activeUnit.anims.play('stop', true);
                showArrows(activeUnit);
            }
        }
    }

    //---------------------------- Global vars ----------------------------

    var config = {
        type: Phaser.AUTO,
        parent: 'game',
        pixelArt: true,
        scale: {
            mode: Phaser.Scale.NONE //,
            //autoCenter: Phaser.Scale.CENTER_BOTH
        },
        width: 800,
        height: 600,
        debug: true,
        physics: {
            default: 'arcade',
            arcade: {
                debug: false
            }
        },
        scene: [
            BootScene,
            StartScene,
            GameScene,
            UIScene,
        ],
        pipeline: {'Custom': CustomPipeline, 'Gray': GrayScalePipeline}
    };

    var map;
    var groundLayer;
    var wallsLayer;
    var objectLayer;
    var fireballAnimation = null;
    var gasAnimation = null;
    var players = [];
    var playerInd = 0;
    var entities = [];
    var units = [];
    var arrows = [];
    var selectedUnit = null;
    var pointerBlocked = false;
    var pointerPressed = false;
    var activeInteractionScenario = userInteractionScenario.movement;
    var grayScalePipeline;
    var customPipeline;
    var rangeRenderer = null;
    var placeSelector = null;

    var baseShader;
    var cam;

    var buttonEndTurn = null;
    //+debug
    var buttonAIStep = null;  
    //-
    var book = null;
    var uiScene = null;
    var startScene = null;
    var uiElements = [];
    var game = new Phaser.Game(config);
    
    const PlayerControl = { human: 'human', computer: 'computer' };
    const SpellDistribution = { random: 'random', unlimited: 'unlimited'};
    var playersSettings = [];
    var gameSettings = {
        spellDistrib:  SpellDistribution.random,
        magicPoints: 25,
        selectedMap: '',
        showEnemyMoves: true,
        rules: 'standard',
        randomMapConfig: { width: 40, height: 30 },
    };

</script>
</body>
</html>